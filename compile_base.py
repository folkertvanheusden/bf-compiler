#! /usr/bin/python

# Written by Folkert van Heusden
# Released in the public domain

import sys

class CompileBase:
    allCode = None
    aclen = None
    blocks = []
    lindentlevel = 0
    functionsFirst = True
    doOptimize = True

    statsIncDataPtrN = 0
    statsIncDataPtrCnt = 0
    statsDecDataPtrN = 0
    statsDecDataPtrCnt = 0
    statsIncDataN = 0
    statsIncDataCnt = 0
    statsDecDataN = 0
    statsDecDataCnt = 0
    statsEmitCharN = 0
    statsEmitCharCnt = 0
    statsGetCharN = 0
    statsGetCharCnt = 0
    statsLoopN = 0
    statsLoopCnt = 0
    statsCommentN = 0
    statsCommentCnt = 0
    statsBlockUsedCnt = 0

    copyrightNotice = [ 'This code was generated by the', 'Brainfuck to * compiler suite', 'written by', 'Folkert van Heusden', 'mail@vanheusden.com / www.vanheusden.com', '(C) 2016-2025 by Folkert van Heusden', 'Released in the public domain' ]

    def header(self, file):
        pass

    def get_name():
        pass

    def loadBFCode(self, file):
        with open(file, 'r') as fh:
            temp = fh.read()

            line = 0
            col = 0

            self.allCode = []

            for c in temp:
                if c == '\n':
                    line += 1
                    col = 0

                else:
                    self.allCode.append((c, line, col))

                    col += 1

            self.aclen = len(self.allCode)

    def genindent(self, level):
        return None

    def invokeFunction(self, funcNr):
        pass

    def addToDataPtr(self, n, dot, position):
        pass

    def subFromDataPtr(self, n, dot, position):
        pass

    def addToData(self, n, dot, position):
        pass

    def subFromData(self, n, dot, position):
        pass

    def emitCharacter(self, n, dot):
        pass

    def readStdin(self, n):
        msg = 'Read from keyboard not supported (%d times)' % n
        print(msg, file=sys.stderr)
        self.addComment(msg)

    def startLoop(self, n, position):
        pass

    def finishLoop(self, n, dot, position):
        pass

    def addComment(self, s):
        pass

    def multilineCommentStart(self):
        pass

    def multilineCommentLine(self, s):
        pass

    def multilineCommentEnd(self):
        pass

    def addComments(self, s):
        if isinstance(s, list):
            parts = s
        else:
            parts = s.split('\n')

        isLf = False
        first = True
        for p in parts:
            p = p.rstrip('\n')

            if len(p) == 0:
                isLf = True

            else:
                if first:
                    first = False
                    self.multilineCommentStart()

                if isLf:
                    isLf = False
                    self.multilineCommentLine('')

                self.multilineCommentLine(p)

        if not first:
            self.multilineCommentEnd()

    def emitProgramBootstrap(self, file):
        pass

    def emitProgramTail(self):
        pass

    def emitFunctions(self):
        pass

    def translate(self, start, end):
        comments = ''

        i = start
        while i < end:
            found = False

            if i > start:
                for j in range(0, len(self.blocks)):
                    blockStart = self.blocks[j][0]
                    nChars = self.blocks[j][1] - blockStart

                    compare1 = ''.join([ c[0] for c in self.allCode[i:i + nChars] ])
                    compare2 = ''.join([ c[0] for c in self.allCode[blockStart:blockStart + nChars] ])

                    if compare1 == compare2:
                        self.statsBlockUsedCnt += 1
                        self.invokeFunction(j)
                        found = True
                        i += nChars
                        break

            if found == False:
                position = (self.allCode[i][1], self.allCode[i][2])

                c = self.allCode[i][0]

                n = 0
                while i < self.aclen and self.allCode[i][0] == c and i < end:
                    i += 1
                    n += 1

                dot = ''
                if i == end:
                    dot = '.'

                if c == '>':
                    self.addComments(comments)
                    comments = ''

                    self.statsIncDataPtrN += n
                    self.statsIncDataPtrCnt += 1

                    self.addToDataPtr(n, dot, position)

                elif c == '<':
                    self.addComments(comments)
                    comments = ''

                    self.statsDecDataPtrN += n
                    self.statsDecDataPtrCnt += 1

                    self.subFromDataPtr(n, dot, position)

                elif c == '+':
                    self.addComments(comments)
                    comments = ''

                    self.statsIncDataN += n
                    self.statsIncDataCnt += 1

                    self.addToData(n, dot, position)

                elif c == '-':
                    self.addComments(comments)
                    comments = ''

                    self.statsDecDataN += n
                    self.statsDecDataCnt += 1

                    self.subFromData(n, dot, position)

                elif c == '.':
                    self.addComments(comments)
                    comments = ''

                    self.statsEmitCharN += n
                    self.statsEmitCharCnt += 1

                    self.emitCharacter(n, dot)

                elif c == ',':
                    self.addComments(comments)
                    comments = ''

                    self.statsGetCharN += n
                    self.statsGetCharCnt += 1

                    self.readStdin(n)

                elif c == '[':
                    self.addComments(comments)
                    comments = ''

                    self.statsLoopN += n
                    self.statsLoopCnt += 1

                    self.startLoop(n, position)

                elif c == ']':
                    self.addComments(comments)
                    comments = ''

                    self.finishLoop(n, dot, position)

                else:
                    comments += c * n

                    self.statsCommentN += n
                    self.statsCommentCnt += 1

        if len(comments):
            self.addComments(comments)

    def countCodeOccurences(self, block, end):
        compare1 = ''.join([ c[0] for c in block ])

        compare2 = ''.join([ c[0] for c in self.allCode[0:end] ])

        return compare2.count(compare1)

    def optimize(self):
        i = 0
        while i < self.aclen:
            if self.allCode[i][0] == '[':
                counter = 1

                j = i
                while counter > 0:
                    j += 1

                    if self.allCode[j][0] == '[':
                        counter += 1

                    if self.allCode[j][0] == ']':
                        counter -= 1

                curBlock = self.allCode[i:j + 1]

                if self.countCodeOccurences(curBlock, self.aclen) > 1 and j - i > 1:
                    if self.countCodeOccurences(curBlock, i) == 0:
                        self.blocks.append((i, j + 1))

                    i = j + 1

                else:
                    i += 1

            else:
                i += 1

    def emitMainFunction(self):
        pass

    def printStats(self):
        print('count inc/dec data ptr: %d/%d' % (self.statsIncDataPtrN, self.statsDecDataPtrN), file=sys.stderr)
        print('value inc/dec data ptr: %d/%d' % (self.statsIncDataPtrCnt, self.statsDecDataPtrCnt), file=sys.stderr)
        print('count inc/dec data: %d/%d' % (self.statsIncDataN, self.statsDecDataN), file=sys.stderr)
        print('value inc/dec data: %d/%d' % (self.statsIncDataCnt, self.statsDecDataCnt), file=sys.stderr)
        print('emit char count/value: %d/%d' % (self.statsEmitCharN, self.statsEmitCharCnt), file=sys.stderr)
        print('get char count/value: %d/%d' % (self.statsGetCharN, self.statsGetCharCnt), file=sys.stderr)
        print('loops count/value: %d/%d' % (self.statsLoopN, self.statsLoopCnt), file=sys.stderr)
        print('comment count/value: %d/%d' % (self.statsCommentN, self.statsCommentCnt), file=sys.stderr)
        print('number of functions/used: %d/%d' % (len(self.blocks), self.statsBlockUsedCnt), file=sys.stderr)
        print('', file=sys.stderr)

    def main(self, file):
        print('(C) 2016-2025 by Folkert van Heusden <mail@vanheusden.com>', file=sys.stderr)
        print('Released in the public domain', file=sys.stderr)
        print('', file=sys.stderr)
        print('This program reads the brainfuck source-code from stdin.', file=sys.stderr)
        print('', file=sys.stderr)

        self.header()

        self.loadBFCode(file)

        if self.doOptimize:
            self.optimize()

        self.emitProgramBootstrap(file)

        if self.functionsFirst:
            self.emitFunctions()

        self.emitMainFunction()

        if not self.functionsFirst:
            self.emitFunctions()

        self.emitProgramTail()

        self.printStats()
