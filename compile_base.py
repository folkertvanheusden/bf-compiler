#! /usr/bin/python

# Written by Folkert van Heusden
# Released under AGPL v3.0

# This file was obtained from https://www.vanheusden.com/misc/blog/2016-05-19_brainfuck_compilers_compared.php

import sys

class CompileBase:
	allCode = None
	aclen = None
	blocks = []
	lindentlevel = 0
	functionsFirst = True
	doOptimize = True

	statsIncDataPtrN = 0
	statsIncDataPtrCnt = 0
	statsDecDataPtrN = 0
	statsDecDataPtrCnt = 0
	statsIncDataN = 0
	statsIncDataCnt = 0
	statsDecDataN = 0
	statsDecDataCnt = 0
	statsEmitCharN = 0
	statsEmitCharCnt = 0
	statsGetCharN = 0
	statsGetCharCnt = 0
	statsLoopN = 0
	statsLoopCnt = 0
	statsCommentN = 0
	statsCommentCnt = 0
	statsBlockUsedCnt = 0

	copyrightNotice = [ 'This code was generated by the', 'Brainfuck to * compiler suite', 'written by', 'Folkert van Heusden', 'mail@vanheusden.com / www.vanheusden.com', '(C) 2016-2018 by Folkert van Heusden', 'Released under AGPL v3.0 license' ]

	def header(self):
		pass

	def loadBFCode(self):
		self.allCode = sys.stdin.read().replace('\n', '')
		self.aclen = len(self.allCode)

	def genindent(self, level):
		return None

	def invokeFunction(self, funcNr):
		pass

	def addToDataPtr(self, n, dot):
		pass

	def subFromDataPtr(self, n, dot):
		pass

	def addToData(self, n, dot):
		pass

	def subFromData(self, n, dot):
		pass

	def emitCharacter(self, n, dot):
		pass

	def readStdin(self, n):
		msg = 'Read from keyboard not supported (%d times)' % n
		print >>sys.stderr, msg
		self.addComment(msg)

	def startLoop(self, n):
		pass

	def finishLoop(self, n, dot):
		pass

	def addComment(self, s):
		pass

	def multilineCommentStart(self):
		pass

	def multilineCommentLine(self, s):
		pass

	def multilineCommentEnd(self):
		pass

	def addComments(self, s):
		if isinstance(s, list):
			parts = s
		else:
			parts = s.split('\n')

		isLf = False
		first = True
		for p in parts:
			p = p.rstrip('\n')

			if len(p) == 0:
				isLf = True

			else:
				if first:
					first = False
					self.multilineCommentStart()

				if isLf:
					isLf = False
					self.multilineCommentLine('')

				self.multilineCommentLine(p)

		if not first:
			self.multilineCommentEnd()

	def emitProgramBootstrap(self):
		pass

	def emitProgramTail(self):
		pass

	def emitFunctions(self):
		pass

	def translate(self, start, end):
		comments = ''

		i = start
		while i < end:
			found = False

			if i > start:
				for j in xrange(0, len(self.blocks)):
					blockStart = self.blocks[j][0]
					nChars = self.blocks[j][1] - blockStart

					if self.allCode[i:i + nChars] == self.allCode[blockStart:blockStart + nChars]:
						self.statsBlockUsedCnt += 1
						self.invokeFunction(j)
						found = True
						i += nChars
						break

			if found == False:
				c = self.allCode[i]

				n = 0
				while i < self.aclen and self.allCode[i] == c and i < end:
					i += 1
					n += 1

				dot = ''
				if i == end:
					dot = '.'

				if c == '>':
					self.addComments(comments)
					comments = ''

					self.statsIncDataPtrN += n
					self.statsIncDataPtrCnt += 1

					self.addToDataPtr(n, dot)

				elif c == '<':
					self.addComments(comments)
					comments = ''

					self.statsDecDataPtrN += n
					self.statsDecDataPtrCnt += 1

					self.subFromDataPtr(n, dot)

				elif c == '+':
					self.addComments(comments)
					comments = ''

					self.statsIncDataN += n
					self.statsIncDataCnt += 1

					self.addToData(n, dot)

				elif c == '-':
					self.addComments(comments)
					comments = ''

					self.statsDecDataN += n
					self.statsDecDataCnt += 1

					self.subFromData(n, dot)

				elif c == '.':
					self.addComments(comments)
					comments = ''

					self.statsEmitCharN += n
					self.statsEmitCharCnt += 1

					self.emitCharacter(n, dot)

				elif c == ',':
					self.addComments(comments)
					comments = ''

					self.statsGetCharN += n
					self.statsGetCharCnt += 1

					self.readStdin(n)

				elif c == '[':
					self.addComments(comments)
					comments = ''

					self.statsLoopN += n
					self.statsLoopCnt += 1

					self.startLoop(n)

				elif c == ']':
					self.addComments(comments)
					comments = ''

					self.finishLoop(n, dot)

				else:
					comments += c * n

					self.statsCommentN += n
					self.statsCommentCnt += 1

		if len(comments):
			self.addComments(comments)

	def optimize(self):
		i = 0
		while i < self.aclen:
			if self.allCode[i] == '[':
				counter = 1

				j = i
				while counter > 0:
					j += 1

					if self.allCode[j] == '[':
						counter += 1

					if self.allCode[j] == ']':
						counter -= 1

				curBlock = self.allCode[i:j + 1]

				if self.allCode.count(curBlock) > 1 and j - i > 1:
					if self.allCode[0:i].count(curBlock) == 0:
						self.blocks.append((i, j + 1))

					i = j + 1

				else:
					i += 1

			else:
				i += 1

	def emitMainFunction(self):
		pass

	def printStats(self):
		print >>sys.stderr, 'count inc/dec data ptr: %d/%d' % (self.statsIncDataPtrN, self.statsDecDataPtrN)
		print >>sys.stderr, 'value inc/dec data ptr: %d/%d' % (self.statsIncDataPtrCnt, self.statsDecDataPtrCnt)
		print >>sys.stderr, 'count inc/dec data: %d/%d' % (self.statsIncDataN, self.statsDecDataN)
		print >>sys.stderr, 'value inc/dec data: %d/%d' % (self.statsIncDataCnt, self.statsDecDataCnt)
		print >>sys.stderr, 'emit char count/value: %d/%d' % (self.statsEmitCharN, self.statsEmitCharCnt)
		print >>sys.stderr, 'get char count/value: %d/%d' % (self.statsGetCharN, self.statsGetCharCnt)
		print >>sys.stderr, 'loops count/value: %d/%d' % (self.statsLoopN, self.statsLoopCnt)
		print >>sys.stderr, 'comment count/value: %d/%d' % (self.statsCommentN, self.statsCommentCnt)
		print >>sys.stderr, 'number of functions/used: %d/%d' % (len(self.blocks), self.statsBlockUsedCnt)
		print >>sys.stderr, ''

	def main(self):
		print >>sys.stderr, '(C) 2016-2018 by Folkert van Heusden <mail@vanheusden.com>'
		print >>sys.stderr, 'Released under AGPL v3.0'
		print >>sys.stderr, ''
		print >>sys.stderr, 'This program reads the brainfuck source-code from stdin.'
		print >>sys.stderr, ''

		self.header()

		self.loadBFCode()

		self.emitProgramBootstrap()

		if self.doOptimize:
			self.optimize()

		if self.functionsFirst:
			self.emitFunctions()

		self.emitMainFunction()

		if not self.functionsFirst:
			self.emitFunctions()

		self.emitProgramTail()

		self.printStats()
